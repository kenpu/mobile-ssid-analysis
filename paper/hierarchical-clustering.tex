\newcommand{\bssid}{\mathbf{B}}
\newcommand{\ssid}{\mathrm{BSSID}}
\renewcommand{\SS}{\mathbf{S}}
\newcommand{\FF}{\mathbf{F}}

\section{Problem Definition}

\label{sec:problem-def}

A mobile device can make a scan.  We refer to each scan as a {\em reading}.
Each reading is defined as $\left<t(r), \bssid(r)\right>$ where $t(r)$ is
the timestamp of the reading, and $\bssid(r)\subseteq\mathrm{BSSID}$ is a set of
BSSID of the wifi hotspots that the scan detected. For each BSSID $b\in
\bssid(r)$ detected in the reading, we also have the SSID and the signal
strength, written respectively as:
$\ssid(b)$ and $s(b|r)$.  We assume that each BSSID has a unique SSID, while the
strength of a BSSID is specific to a given reading.

\subsection{Location identification and inference}

\begin{definition}
    A {\em timeline} $T$ is a sequence of readings.  
    We denote $T_i$ as the $i$-th reading of the timeline $T$.

    A {\em segment} of the timeline $S$ is a contiguous subsequence of $T$.
\end{definition}

Let $\mathcal{L}$ be a (unspecified) finite set of {\em locations}.

\begin{definition}[Location identification]
    A {\em location identification} problem consists of several subproblems:

    \begin{enumerate}
        \item {\em Identification} of the distinct locations $\mathcal{L}$ from
            a given timeline $T$.
        \item {\em Inference} of the location of a given reading.
    \end{enumerate}
\end{definition}

\subsection{Real-life challenges}

\begin{itemize}
    \item Power-aware sensing creates highly irregular sampling intervals.
    \item False positive in the readings - phantom BSSID
    \item False negatives in the readings - undetected BSSID
    \item Transient hotspots - while driving
    \item Non-stationary hotspots
    \item Location is naturally a hierarchical concept
    \item Online algorithm
\end{itemize}


\begin{figure*}
    \begin{verbatim}
    (defn online-cluster
        [H tail C-new]
        (let [root (root H)
              prev (sibling tail)
              parent (parent tail)]
            (cond
                (= tail root)
                    (set-root! H (new-cluster root C-new))
                (closer? (C-new tail) :than (prev tail))
                    (do
                        (detach! H tail)
                        (promote! H prev)
                        (online-cluster H prev (new-cluster tail C-new)))
                :else
                    (do
                        (online-cluster H parent C-new)))))
    \end{verbatim}
\caption{Algorithm to perform online clustering}
\end{figure*}

\section{The Algorithm}

\subsection{Segmentation}

Given the timeline $T$. We want to partition $T$ into a collection of
non-overlapping segments $\{S_i\}$, where each $S_i$ is such that all the
readings $r\in S_i$ are at the same location.

The challenge is that the locations, at this stage, are still unidentified, and
furthemore, as stated in Section~\ref{sec:problem-def}, we wish to solve the
multiresolution localization problem.  Thus, instead of partitioning the
timeline, our objective is to perform a hierarchical segmentation of the
timeline, as defined in Definition~\ref{def:h-seg}.

\begin{definition}[(Binary) Hierarchical segmentation]
    A binary hierarhical segmentation of a timeline $T$ is defined as a binary
    tree of vertices.  The leaf vertices contain a single reading, while the
    interior vertices have two adjacent vertices as children.
    \label{def:h-seg}
\end{definition}

We define the following:

Given a vertex $v$, the readings of $v$, $R(v)$, is given by:
\begin{itemize}
    \item If $v\in \mathrm{Leaves}(H)$, then $R(v) = \{r(v)\}$.
    \item Otherwise, $R(v) = R(\mathrm{left}(v)) \cup R(\mathrm{right}(v))$.
\end{itemize}

The constraint of $H$ is such that:

\begin{itemize}
    \item $H$ must form a cover of $T$.  Namely, every reading must belong to
        some $R(v)$.
    \item For each vertex $v$, $R(\mathrm{left}(v))$ and $R(\mathrm{right}(v))$
        are contiguous segments in $T$.
\end{itemize}

We introduce a homogeneity measure for each vertex to measure whether the vertex
covers a segment of readings at a single location.

\begin{definition}[Vertex minsim]
    Given vertex $v$ covering a range of readings $R(v)$, we define the minsim
    as the mininum similarity:
    $$\mathrm{minsim}(v) = \min\{\mathrm{sim}(r, r'): r, r'\in R(v)\}$$
\end{definition}

\begin{proposition}
    $\mathrm{minsim}$ is monotonic with respect to the hierarchy $H$, with the
    root of $H$ having the minimal $\mathrm{minsim}$ value.
\end{proposition}

We can efficiently compute the $\mathrm{minsim}(v)$ in a bottom-up fashion.

\begin{figure}
    \begin{verbatim}
    (defn minsim [v]
        (if (or (zero? (minsim (left v))) 
                (zero? (minsim (right v))))
            0
            (min (minsim (left v))
                 (minsim (right v))
                 (minsim (R v)))))
    \end{verbatim}
    \caption{Minsim computation}
\end{figure}

For overall large vertices, we rely on an approximation based on sampling:

$\mathrm{minsim}(R(v))$ can be approximated by:
\begin{itemize}
    \item Sample $K_1$ from $R(\mathrm{left}(v))$ and $K_2$ from
        $R(\mathrm{right}(v)$.
    \item Compute the minsim of the $K_1\times K_2$ pairs, and use it as an
        estimation of $\mathrm{minsim}(v)$.
\end{itemize}

\begin{definition}[Segmentation]
    Given a threshold $c$, a vertex is a {\em maximally} homogeneous if:
    \begin{itemize}
        \item $\mathrm{minsim}(v) \geq c$, and
        \item $\mathrm{minsim}(\mathrm{parent}(v)) < c$
    \end{itemize}
\end{definition}

Let $\SS(H|c)$ be the maximally homogeneous vertices in $H$ with respect to
threshold $c$.

The next stop is the clean $\SS(H|c)$.  For each vertex
$v\in\SS(H|c)$, we assert that it must have sufficient temporal and
reading support.  Let $\SS^*(H|c)$ be the vertices $v$ such
that $\Delta t(v)\geq \tau$.

\subsection{Location Identification}

We need to construct a set of locations $\mathcal{L}$, and a mapping
$$h:\SS^*(H|c)\to \mathcal{L}$$
that identifies the locations of the segments in $\SS^*(H|c)$.

This is done using a fast clustering algorithm.

\begin{figure*}
    \begin{verbatim}
    (loop [segments (segmentation H)
           locs     []]
        (cond
            (empty? segments) locs
            (empty? locs) (recur (rest segments)
                                 (conj locs (first segments)))
            :else
                (let [seg (first segments)
                      segments (rest segments)]
                    (if-let [loc (nearest locs seg)]
                        (recur segments
                               (assoc (:name loc) (augment loc segment)))
                        (recur segments
                               (conj locs (new-location seg)))))))
    \end{verbatim}
\end{figure*}

In hierarchical localization, we wish to generate a hierarchical organization of
the fundamental locations. We already have a hierarchical organization of
$\SS^*(H|c)$.  So, we want to use it to {\em induce} a hierarchy of
locations.

\begin{figure*}
    \begin{verbatim}
    segments is a queue of S*(H|c)
    forest
    while (not-empty? segments)
         seg <- (pop segments)
         (add seg :to forest)
         parent = (parent-of seg)
         if (not-in-queue? parent)
            (push parent :into segments)

    (defn add [seg :to forest]
        (let [subF (for [F forest :when (is-subset? F seg)
                        (location-of F))]
            (merge subF :in forest)))
    \end{verbatim}
\end{figure*}


